+ 解法原则  
记作当前节点为cur  
    + 如果cur无左孩子，cur向右移动（cur=cur.right）  
    + 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright
        + 如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）  
        + 如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）  
    
左子树的最右节点与根节点连接


+ 前序遍历
  + 如果当前节点左孩子 cur->left 为空，`输出当前节点 cur`并指向右孩子 cur->right
  + 如果当前节点左孩子 cur->left 不为空，那么在当前节点 cur 的左子树中找出前驱节点 pre，也就是左子树中最右的节点
    + 如果前驱节点的右孩子 pre->right 为空, 那么将右孩子指向当前节点 cur , `输出当前节点`, 当前节点 cur 更新为当前节点 cur 的左孩子
    + 如果前驱节点的右孩子 pre->right 不为空, 也就是指向当前节点 cur, 重新将右孩子设为空。当前节点 cur 更新为当前节点 cur 的右孩子
  + 重复前两步
 

+ 中序遍历
  + 如果当前节点左孩子 cur->left 为空, `输出当前节点 cur`并指向右孩子 cur->right
  + 如果当前节点左孩子 cur->left 不为空, 那么在当前节点 cur 的左子树中找出前驱节点 pre, 也就是左子树中最右的节点
    + 如果前驱节点的右孩子 pre->right 为空, 那么将右孩子指向当前节点 cur , 当前节点更新为当前节点 cur 的左孩子
    + 如果前驱节点的右孩子 pre->right 不为空, 也就是指向当前节点 cur, 重新将右孩子设为空. `输出当前节点`, 当前节点 cur 更新为当前节点 cur 的右孩子
  + 重复前两步


+ 后序遍历
  + 如果当前节点 cur 的左孩子为空, 则将其右孩子作为当前节点
  + 如果当前节点 cur 的左孩子不为空, 在当前节点 cur 的左子树中找到当前节点在中序遍历下的前驱节点 pre
    + 如果前驱节点的右孩子为空, 将它的右孩子设置为当前节点 cur , 当前节点更新为当前节点 cur 的左孩子
    + 如果前驱节点的右孩子为当前节点 cur , 将它的右孩子重新设为空, 倒序输出从当前节点 cur 的左孩子到该前驱节点 pre 这条路径上的所有节点, 当前节点 cur 更新为当前节点的右孩子。